package com.sun.tools.javac.util;
/*
* Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
*
* This code is free software; you can redistribute it and/or modify it
* under the terms of the GNU General Public License version 2 only, as
* published by the Free Software Foundation.  Oracle designates this
* particular file as subject to the "Classpath" exception as provided
* by Oracle in the LICENSE file that accompanied this code.
*
* This code is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
* version 2 for more details (a copy is included in the LICENSE file that
* accompanied this code).
*
* You should have received a copy of the GNU General Public License version
* 2 along with this work; if not, write to the Free Software Foundation,
* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
*
* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
* or visit www.oracle.com if you need additional information or have any
* questions.
*/
/** An abstraction of a diagnostic message generated by the compiler.
*
*  <p><b>This is NOT part of any supported API.
*  If you write code that depends on this, you do so at your own risk.
*  This code and its internal interfaces are subject to change or
*  deletion without notice.</b>
*/
extern class JCDiagnostic implements javax.tools.Diagnostic<javax.tools.JavaFileObject>
{
	/**
	* Create a fragment diagnostic, for use as an argument in other diagnostics
	*  @param key    The key for the localized error message.
	*  @param args   Fields of the error message.
	*
	*/
	@:overload public static function fragment(key : String, args : java.NativeArray<Dynamic>) : com.sun.tools.javac.util.JCDiagnostic;
	
	@:overload public static function getFragmentFormatter() : com.sun.tools.javac.api.DiagnosticFormatter<com.sun.tools.javac.util.JCDiagnostic>;
	
	private var args(default, null) : java.NativeArray<Dynamic>;
	
	/**
	* Create a diagnostic object.
	* @param fomatter the formatter to use for the diagnostic
	* @param dt the type of diagnostic
	* @param lc     the lint category for the diagnostic
	* @param source the name of the source file, or null if none.
	* @param pos the character offset within the source file, if given.
	* @param key a resource key to identify the text of the diagnostic
	* @param args arguments to be included in the text of the diagnostic
	*/
	@:overload private function new(formatter : com.sun.tools.javac.api.DiagnosticFormatter<com.sun.tools.javac.util.JCDiagnostic>, dt : com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticType, lc : com.sun.tools.javac.code.Lint.Lint_LintCategory, flags : java.util.Set<com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticFlag>, source : com.sun.tools.javac.util.DiagnosticSource, pos : com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticPosition, key : String, args : java.NativeArray<Dynamic>) : Void;
	
	/**
	* Get the type of this diagnostic.
	* @return the type of this diagnostic
	*/
	@:overload public function getType() : com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticType;
	
	/**
	* Get the subdiagnostic list
	* @return subdiagnostic list
	*/
	@:overload public function getSubdiagnostics() : com.sun.tools.javac.util.List<com.sun.tools.javac.util.JCDiagnostic>;
	
	@:overload public function isMultiline() : Bool;
	
	/**
	* Check whether or not this diagnostic is required to be shown.
	* @return true if this diagnostic is required to be shown.
	*/
	@:overload public function isMandatory() : Bool;
	
	/**
	* Check whether this diagnostic has an associated lint category.
	*/
	@:overload public function hasLintCategory() : Bool;
	
	/**
	* Get the associated lint category, or null if none.
	*/
	@:overload public function getLintCategory() : com.sun.tools.javac.code.Lint.Lint_LintCategory;
	
	/**
	* Get the name of the source file referred to by this diagnostic.
	* @return the name of the source referred to with this diagnostic, or null if none
	*/
	@:overload public function getSource() : javax.tools.JavaFileObject;
	
	/**
	* Get the source referred to by this diagnostic.
	* @return the source referred to with this diagnostic, or null if none
	*/
	@:overload public function getDiagnosticSource() : com.sun.tools.javac.util.DiagnosticSource;
	
	@:overload private function getIntStartPosition() : Int;
	
	@:overload private function getIntPosition() : Int;
	
	@:overload private function getIntEndPosition() : Int;
	
	@:overload public function getStartPosition() : haxe.Int64;
	
	@:overload public function getPosition() : haxe.Int64;
	
	@:overload public function getEndPosition() : haxe.Int64;
	
	/**
	* Get the line number within the source referred to by this diagnostic.
	* @return  the line number within the source referred to by this diagnostic
	*/
	@:overload public function getLineNumber() : haxe.Int64;
	
	/**
	* Get the column number within the line of source referred to by this diagnostic.
	* @return  the column number within the line of source referred to by this diagnostic
	*/
	@:overload public function getColumnNumber() : haxe.Int64;
	
	/**
	* Get the arguments to be included in the text of the diagnostic.
	* @return  the arguments to be included in the text of the diagnostic
	*/
	@:overload public function getArgs() : java.NativeArray<Dynamic>;
	
	/**
	* Get the prefix string associated with this type of diagnostic.
	* @return the prefix string associated with this type of diagnostic
	*/
	@:overload public function getPrefix() : String;
	
	/**
	* Get the prefix string associated with a particular type of diagnostic.
	* @return the prefix string associated with a particular type of diagnostic
	*/
	@:overload public function getPrefix(dt : com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticType) : String;
	
	/**
	* Return the standard presentation of this diagnostic.
	*/
	@:overload public function toString() : String;
	
	@:overload public function getKind() : javax.tools.Diagnostic.Diagnostic_Kind;
	
	@:overload public function getCode() : String;
	
	@:overload public function getMessage(locale : java.util.Locale) : String;
	
	@:overload public function setFlag(flag : com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticFlag) : Void;
	
	@:overload public function isFlagSet(flag : com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticFlag) : Bool;
	
	
}
/** A factory for creating diagnostic objects. */
@:native('com$sun$tools$javac$util$JCDiagnostic$Factory') extern class JCDiagnostic_Factory
{
	/** The context key for the diagnostic factory. */
	private static var diagnosticFactoryKey(default, null) : com.sun.tools.javac.util.Context.Context_Key<com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_Factory>;
	
	/** Get the Factory instance for this context. */
	@:overload public static function instance(context : com.sun.tools.javac.util.Context) : com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_Factory;
	
	/** Create a new diagnostic factory. */
	@:overload private function new(context : com.sun.tools.javac.util.Context) : Void;
	
	/** Create a new diagnostic factory. */
	@:overload public function new(messages : com.sun.tools.javac.util.JavacMessages, prefix : String) : Void;
	
	/**
	* Create an error diagnostic.
	*  @param source The source of the compilation unit, if any, in which to report the error.
	*  @param pos    The source position at which to report the error.
	*  @param key    The key for the localized error message.
	*  @param args   Fields of the error message.
	*/
	@:overload public function error(source : com.sun.tools.javac.util.DiagnosticSource, pos : com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticPosition, key : String, args : java.NativeArray<Dynamic>) : com.sun.tools.javac.util.JCDiagnostic;
	
	/**
	* Create a warning diagnostic that will not be hidden by the -nowarn or -Xlint:none options.
	*  @param source The source of the compilation unit, if any, in which to report the warning.
	*  @param pos    The source position at which to report the warning.
	*  @param key    The key for the localized warning message.
	*  @param args   Fields of the warning message.
	*  @see MandatoryWarningHandler
	*/
	@:overload public function mandatoryWarning(source : com.sun.tools.javac.util.DiagnosticSource, pos : com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticPosition, key : String, args : java.NativeArray<Dynamic>) : com.sun.tools.javac.util.JCDiagnostic;
	
	/**
	* Create a warning diagnostic that will not be hidden by the -nowarn or -Xlint:none options.
	*  @param lc     The lint category for the diagnostic
	*  @param source The source of the compilation unit, if any, in which to report the warning.
	*  @param pos    The source position at which to report the warning.
	*  @param key    The key for the localized warning message.
	*  @param args   Fields of the warning message.
	*  @see MandatoryWarningHandler
	*/
	@:overload public function mandatoryWarning(lc : com.sun.tools.javac.code.Lint.Lint_LintCategory, source : com.sun.tools.javac.util.DiagnosticSource, pos : com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticPosition, key : String, args : java.NativeArray<Dynamic>) : com.sun.tools.javac.util.JCDiagnostic;
	
	/**
	* Create a warning diagnostic.
	*  @param lc     The lint category for the diagnostic
	*  @param key    The key for the localized error message.
	*  @param args   Fields of the warning message.
	*  @see MandatoryWarningHandler
	*/
	@:overload public function warning(lc : com.sun.tools.javac.code.Lint.Lint_LintCategory, key : String, args : java.NativeArray<Dynamic>) : com.sun.tools.javac.util.JCDiagnostic;
	
	/**
	* Create a warning diagnostic.
	*  @param source The source of the compilation unit, if any, in which to report the warning.
	*  @param pos    The source position at which to report the warning.
	*  @param key    The key for the localized warning message.
	*  @param args   Fields of the warning message.
	*/
	@:overload public function warning(source : com.sun.tools.javac.util.DiagnosticSource, pos : com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticPosition, key : String, args : java.NativeArray<Dynamic>) : com.sun.tools.javac.util.JCDiagnostic;
	
	/**
	* Create a warning diagnostic.
	*  @param lc     The lint category for the diagnostic
	*  @param source The source of the compilation unit, if any, in which to report the warning.
	*  @param pos    The source position at which to report the warning.
	*  @param key    The key for the localized warning message.
	*  @param args   Fields of the warning message.
	*  @see MandatoryWarningHandler
	*/
	@:overload public function warning(lc : com.sun.tools.javac.code.Lint.Lint_LintCategory, source : com.sun.tools.javac.util.DiagnosticSource, pos : com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticPosition, key : String, args : java.NativeArray<Dynamic>) : com.sun.tools.javac.util.JCDiagnostic;
	
	/**
	* Create a note diagnostic that will not be hidden by the -nowarn or -Xlint:none options.
	*  @param key    The key for the localized message.
	*  @param args   Fields of the message.
	*  @see MandatoryWarningHandler
	*/
	@:overload public function mandatoryNote(source : com.sun.tools.javac.util.DiagnosticSource, key : String, args : java.NativeArray<Dynamic>) : com.sun.tools.javac.util.JCDiagnostic;
	
	/**
	* Create a note diagnostic.
	*  @param key    The key for the localized error message.
	*  @param args   Fields of the message.
	*/
	@:overload public function note(key : String, args : java.NativeArray<Dynamic>) : com.sun.tools.javac.util.JCDiagnostic;
	
	/**
	* Create a note diagnostic.
	*  @param source The source of the compilation unit, if any, in which to report the note.
	*  @param pos    The source position at which to report the note.
	*  @param key    The key for the localized message.
	*  @param args   Fields of the message.
	*/
	@:overload public function note(source : com.sun.tools.javac.util.DiagnosticSource, pos : com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticPosition, key : String, args : java.NativeArray<Dynamic>) : com.sun.tools.javac.util.JCDiagnostic;
	
	/**
	* Create a fragment diagnostic, for use as an argument in other diagnostics
	*  @param key    The key for the localized message.
	*  @param args   Fields of the message.
	*/
	@:overload public function fragment(key : String, args : java.NativeArray<Dynamic>) : com.sun.tools.javac.util.JCDiagnostic;
	
	/**
	* Create a new diagnostic of the given kind, which is not mandatory and which has
	* no lint category.
	*  @param kind        The diagnostic kind
	*  @param ls          The lint category, if applicable, or null
	*  @param source      The source of the compilation unit, if any, in which to report the message.
	*  @param pos         The source position at which to report the message.
	*  @param key         The key for the localized message.
	*  @param args        Fields of the message.
	*/
	@:overload public function create(kind : com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticType, source : com.sun.tools.javac.util.DiagnosticSource, pos : com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticPosition, key : String, args : java.NativeArray<Dynamic>) : com.sun.tools.javac.util.JCDiagnostic;
	
	/**
	* Create a new diagnostic of the given kind.
	*  @param kind        The diagnostic kind
	*  @param lc          The lint category, if applicable, or null
	*  @param isMandatory is diagnostic mandatory?
	*  @param source      The source of the compilation unit, if any, in which to report the message.
	*  @param pos         The source position at which to report the message.
	*  @param key         The key for the localized message.
	*  @param args        Fields of the message.
	*/
	@:overload public function create(kind : com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticType, lc : com.sun.tools.javac.code.Lint.Lint_LintCategory, flags : java.util.Set<com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticFlag>, source : com.sun.tools.javac.util.DiagnosticSource, pos : com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticPosition, key : String, args : java.NativeArray<Dynamic>) : com.sun.tools.javac.util.JCDiagnostic;
	
	@:overload private function qualify(t : com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticType, key : String) : String;
	
	
}
/**
* A DiagnosticType defines the type of the diagnostic.
**/
@:native('com$sun$tools$javac$util$JCDiagnostic$DiagnosticType') extern enum JCDiagnostic_DiagnosticType
{
	/** A fragment of an enclosing diagnostic. */
	FRAGMENT;
	/** A note: similar to, but less serious than, a warning. */
	NOTE;
	/** A warning. */
	WARNING;
	/** An error. */
	ERROR;
	
}

/**
* A DiagnosticPosition provides information about the positions in a file
* that gave rise to a diagnostic. It always defines a "preferred" position
* that most accurately defines the location of the diagnostic, it may also
* provide a related tree node that spans that location.
*/
@:native('com$sun$tools$javac$util$JCDiagnostic$DiagnosticPosition') extern interface JCDiagnostic_DiagnosticPosition
{
	/** Gets the tree node, if any, to which the diagnostic applies. */
	@:overload public function getTree() : com.sun.tools.javac.tree.JCTree;
	
	/** If there is a tree node, get the start position of the tree node.
	*  Otherwise, just returns the same as getPreferredPosition(). */
	@:overload public function getStartPosition() : Int;
	
	/** Get the position within the file that most accurately defines the
	*  location for the diagnostic. */
	@:overload public function getPreferredPosition() : Int;
	
	/** If there is a tree node, and if endPositions are available, get
	*  the end position of the tree node. Otherwise, just returns the
	*  same as getPreferredPosition(). */
	@:overload public function getEndPosition(endPosTable : java.util.Map<com.sun.tools.javac.tree.JCTree, Null<Int>>) : Int;
	
	
}
/**
* A DiagnosticPosition that simply identifies a position, but no related
* tree node, as the location for a diagnostic. Used for scanner and parser
* diagnostics. */
@:native('com$sun$tools$javac$util$JCDiagnostic$SimpleDiagnosticPosition') extern class JCDiagnostic_SimpleDiagnosticPosition implements com.sun.tools.javac.util.JCDiagnostic.JCDiagnostic_DiagnosticPosition
{
	@:overload public function new(pos : Int) : Void;
	
	@:overload public function getTree() : com.sun.tools.javac.tree.JCTree;
	
	@:overload public function getStartPosition() : Int;
	
	@:overload public function getPreferredPosition() : Int;
	
	@:overload public function getEndPosition(endPosTable : java.util.Map<com.sun.tools.javac.tree.JCTree, Null<Int>>) : Int;
	
	
}
@:native('com$sun$tools$javac$util$JCDiagnostic$DiagnosticFlag') extern enum JCDiagnostic_DiagnosticFlag
{
	MANDATORY;
	RESOLVE_ERROR;
	SYNTAX;
	RECOVERABLE;
	
}

@:native('com$sun$tools$javac$util$JCDiagnostic$MultilineDiagnostic') extern class JCDiagnostic_MultilineDiagnostic extends com.sun.tools.javac.util.JCDiagnostic
{
	@:overload public function new(other : com.sun.tools.javac.util.JCDiagnostic, subdiagnostics : com.sun.tools.javac.util.List<com.sun.tools.javac.util.JCDiagnostic>) : Void;
	
	@:overload override public function getSubdiagnostics() : com.sun.tools.javac.util.List<com.sun.tools.javac.util.JCDiagnostic>;
	
	@:overload override public function isMultiline() : Bool;
	
	
}
